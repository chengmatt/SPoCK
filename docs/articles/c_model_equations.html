<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Description of Model Equations • SPoRC</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Description of Model Equations">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">SPoRC</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/index.html">Articles</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Description of Model Equations</h1>
            
      

      <div class="d-none name"><code>c_model_equations.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="process-models-and-equations">Process Models and Equations<a class="anchor" aria-label="anchor" href="#process-models-and-equations"></a>
</h2>
<p><code>SPoRC</code> assumes an annual time-step, where the following
processes are applied in order:</p>
<ol style="list-style-type: decimal">
<li>Recruitment and tag releases initially occur (tag releases occur if
tagging data are used),</li>
<li>Markovian movement of all individuals then occurs,</li>
<li>Total mortality, chronic tag loss (if applicable), and ageing
processes then take place,</li>
</ol>
<p>The aforementioned processes are applied to four main population
partitions, which include region
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>),
year
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>),
age
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mo>+</mo></msub><annotation encoding="application/x-tex">a_+</annotation></semantics></math>,
where the latter indicates the plus group), and sex
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>).
Although <code>SPoRC</code> can accommodate spatial process, all of the
equations described in this vignette can collapse and be generalized to
a single region (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = 1</annotation></semantics></math>).</p>
<div class="section level3">
<h3 id="recruitment-processes">Recruitment Processes<a class="anchor" aria-label="anchor" href="#recruitment-processes"></a>
</h3>
<p>Recruitment processes occur at the beginning of the year and can be
described by either mean recruitment or with a Beverton-Holt stock
recruitment relationship. Annual recruitment generated by a mean
recruitment relationship is governed by the following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><msub><mi>c</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msup><mi>μ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><mo>−</mo><mfrac><msubsup><mi>σ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow><mn>2</mn></msubsup><mn>2</mn></mfrac><msub><mi>b</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">
Rec_{r,y,s} = \mu^{Rec}\exp\left(\epsilon_{r,y}^{Rec}-\frac{\sigma^2_{Rec}}{2}b_y\right)\psi_s\zeta_r
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><msub><mi>c</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Rec_{r,y,s}</annotation></semantics></math>
represents recruitment across regions, years, and sexes.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>μ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msup><annotation encoding="application/x-tex">\mu^{Rec}</annotation></semantics></math>
represents the mean recruitment parameter,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Rec}</annotation></semantics></math>
are the recruitment deviations <a href="#recruitmentpen">constrained by
a normal distribution</a>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mi>y</mi></msub><annotation encoding="application/x-tex">b_y</annotation></semantics></math>
represents values determined from a recruitment bias correction ramp,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mi>s</mi></msub><annotation encoding="application/x-tex">\psi_s</annotation></semantics></math>
is the recruitment sex ratio, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ζ</mi><mi>r</mi></msub><annotation encoding="application/x-tex">\zeta_r</annotation></semantics></math>
are the recruitment apportionment parameters. Recruitment parameterized
as a Beverton-Holt relationship assuming localized density-dependence
can be expressed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><msub><mi>c</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>4</mn><mi>R</mi><mn>0</mn><msub><mi>ζ</mi><mi>r</mi></msub><msub><mi>h</mi><mi>r</mi></msub><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mtext mathvariant="normal">RecLag</mtext></mrow></msub></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>S</mi><mi>B</mi><msub><mn>0</mn><mi>r</mi></msub><mo>+</mo><mn>5</mn><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>h</mi><mi>r</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mtext mathvariant="normal">RecLag</mtext></mrow></msub></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><mo>−</mo><mfrac><msubsup><mi>σ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow><mn>2</mn></msubsup><mn>2</mn></mfrac><msub><mi>b</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ψ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">
Rec_{r,y,s} = \frac{4R0\zeta_rh_rSSB_{r,y-\text{RecLag}}}{(1-h_r)SSB0_r+5(h_r-1)SSB_{r,y-\text{RecLag}}}\exp\left(\epsilon_{r,y}^{Rec}-\frac{\sigma^2_{Rec}}{2}b_y\right)\psi_s 
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">R0</annotation></semantics></math>
is the virgin unfished recruitment,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>r</mi></msub><annotation encoding="application/x-tex">h_r</annotation></semantics></math>
is the steepness parameter representing the fraction of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>0</mn><msub><mi>ζ</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">R0\zeta_r</annotation></semantics></math>
that would be produced when at 20% of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>B</mi><msub><mn>0</mn><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">SSB0_r</annotation></semantics></math>.
The steepness parameter is constrained to be between values of 0.2 and 1
and are estimated in bounded logit space:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>r</mi></msub><mo>=</mo><mn>0.2</mn><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mn>0.2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>h</mi><mi>r</mi><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>h</mi><mi>r</mi><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">
h_r = 0.2 + (1 - 0.2) \frac{\exp(h^{'}_r)}{1 + \exp(h^{'}_r)}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>h</mi><mi>r</mi><mi>′</mi></msubsup><annotation encoding="application/x-tex">h^{'}_r</annotation></semantics></math>
is the steepness parameter in bounded logit space.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>B</mi><msub><mn>0</mn><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">SSB0_r</annotation></semantics></math>
represents the unfished spawning stock biomass computed as the spawning
biomass per recruit multiplied by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>0</mn><msub><mi>ζ</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">R0\zeta_r</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>L</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">RecLag</annotation></semantics></math>
represents the delay between spawning and when recruits enter the
population. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>L</mi><mi>a</mi><mi>g</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">RecLag &gt; y</annotation></semantics></math>,
the model utilizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>B</mi><msub><mn>0</mn><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">SSB0_r</annotation></semantics></math>
instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mi>R</mi><mi>e</mi><mi>c</mi><mi>L</mi><mi>a</mi><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">SSB_(r,y-RecLag)</annotation></semantics></math>
to compute deterministic recruitment.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">SSB_(r,y)</annotation></semantics></math>
is the spawning stock biomass, which is computed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mi>a</mi><mrow><mi>a</mi><mo>+</mo></mrow></munderover><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">spawn</mtext></msubsup><mi>M</mi><mi>a</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">
SSB_{r,y} = \sum_a^{a+} N_{r,y,a,s=1}W_{r,y,a,s=1}^\text{spawn}Mat_{r,y,a,s=1}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">N_{r,y,a,s=1}</annotation></semantics></math>
here represents the numbers at age across regions and years for females
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s = 1</annotation></semantics></math>),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">spawn</mtext></msubsup><annotation encoding="application/x-tex">W_{r,y,a,s=1}^\text{spawn}</annotation></semantics></math>
are values of weight at age for spawning females, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Mat_{r,y,a,s=1}</annotation></semantics></math>
are values of maturity at age. In a single-sex model,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">SSB_{r,y}</annotation></semantics></math>
is simply computed as:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mi>a</mi><mrow><mi>a</mi><mo>+</mo></mrow></msubsup><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">spawn</mtext></msubsup><mo>⋅</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">SSB_{r,y} = \sum_a^{a+} N_{r,y,a,s=1}W_{r,y,a,s=1}^\text{spawn} \cdot 0.5</annotation></semantics></math>.</p>
<p>In a spatial model, regional recruitment apportionment parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ζ</mi><mi>r</mi></msub><annotation encoding="application/x-tex">\zeta_r</annotation></semantics></math>
are derived using a multinomial logit transformation. There are also
additional options that can be specified for recruitment processes in a
spatial model. In particular, users can also specify whether recruitment
occurs globally instead of locally. In such a case, the Beverton-Holt
relatinoship is rewritten as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><msub><mi>c</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>4</mn><mi>R</mi><mn>0</mn><mi>h</mi><munder><mo>∑</mo><mi>r</mi></munder><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mtext mathvariant="normal">RecLag</mtext></mrow></msub></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>S</mi><mi>B</mi><mn>0</mn><mo>+</mo><mn>5</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><munder><mo>∑</mo><mi>r</mi></munder><mi>S</mi><mi>S</mi><msub><mi>B</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mtext mathvariant="normal">RecLag</mtext></mrow></msub></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mi>y</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><mo>−</mo><mfrac><msubsup><mi>σ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow><mn>2</mn></msubsup><mn>2</mn></mfrac><msub><mi>b</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">
Rec_{r,y,s} = \frac{4R0h\sum_rSSB_{r,y-\text{RecLag}}}{(1-h)SSB0+5(h-1)\sum_rSSB_{r,y-\text{RecLag}}}\exp\left(\epsilon_{y}^{Rec}-\frac{\sigma^2_{Rec}}{2}b_y\right)\psi_s\zeta_r
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">SSB</annotation></semantics></math>
is summed across regions, recruitment apportionment parameters are
applied to the overall deterministic recruitment relationship (as
opposed to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">R0</annotation></semantics></math>
in the numerator), and recruitment deviations are estimated
globally.</p>
</div>
<div class="section level3">
<h3 id="population-projection">Population Projection<a class="anchor" aria-label="anchor" href="#population-projection"></a>
</h3>
<p>Following recruitment processes, the population can then be projected
forward. Movement processes first occur:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐍</mi><msub><mi></mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐍</mi><msub><mi></mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mi>𝐌</mi><msub><mi></mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
\boldsymbol{N}{_{y,a,s}} = (\boldsymbol{N}{_{y,a,s}})^T \boldsymbol{M}{_{y,a,s}}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><msub><mi></mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{M}{_{y,a,s}}</annotation></semantics></math>
is a first-order Markov matrix representing movement. In a single-region
case, no movement occurs (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><msub><mi></mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{M}{_{y,a,s}}</annotation></semantics></math>
is an identity matrix). Movement for a given year, age, and sex
combination is constrained by a multinomial logit transformation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ω</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ω</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>,</mo><msub><mi>ω</mi><mrow><mi>j</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
M_{k,j,y,a,s} = \frac{\exp(\omega_{k,j,y,a,s})}{\sum_{k=1}^J\exp(\omega_{k,j,y,a,s})}, \omega_{j,1,y,a,s} = 0
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">\omega_{k,j,y,a,s}</annotation></semantics></math>
are movement parameters in multinomial logit space. Given that movement
parameters must sum to 1 across rows, only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>r</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_r - 1</annotation></semantics></math>
movement parameters are estiamted for a given year, age, and sex
combination. After the population undergoes movement, individuals then
experience mortality and ageing processes following an exponential
mortality model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>=</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
N_{r,y+1,a+1,s} = N_{r,y,a,s}\exp(-Z_{r,y,a,s}), \quad \text{for } 1 \leq a &lt; a_+ \\
N_{r,y+1,a,s} = N_{r,y,a-1,s}\exp(-Z_{r,y,a-1,s}) + N_{r,y,a,s}\exp(-Z_{r,y,a,s}), \quad \text{for } a = a_+
\end{aligned}
</annotation></semantics></math></p>
<p>Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">Z_{r,y,a,s}</annotation></semantics></math>
denotes the total instantaneous mortality:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><munder><mo>∑</mo><mi>f</mi></munder><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">
Z_{r,y,a,s} = Natmort_{r,y,a,s} + \sum_{f} Fmort_{r,y,f} Sel_{r,y,a,s,f}^{Fsh}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Natmort_{r,y,a,s}</annotation></semantics></math>
is the instantaneous natural mortality rate,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Fmort_{r,y,f}</annotation></semantics></math>
is the annual instantaneous fishing mortality rate and for fishery fleet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">Sel_{r,y,a,s,f}^{Fsh}</annotation></semantics></math><a href="#selforms">represents fishery selectivity processes</a>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Fmort_{r,y,f}</annotation></semantics></math>
is determined by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mi>μ</mi><mrow><mi>r</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo>⋅</mo><mi>e</mi><mi>x</mi><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
Fmort_{r,y,f} = \mu^{Fmort}_{r,f} \cdot exp(\epsilon_{r,y,f}^{FishMort})
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>μ</mi><mrow><mi>r</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">\mu^{Fmort}_{r,f}</annotation></semantics></math>
are mean fishing mortality parameters for a given region and fleet, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y,f}^{FishMort}</annotation></semantics></math>
are deviations from the mean, <a href="#fishmortpen">constrained by a
normal distribution</a>.</p>
</div>
<div class="section level3">
<h3 id="population-initialization">Population Initialization<a class="anchor" aria-label="anchor" href="#population-initialization"></a>
</h3>
<p>Several options are available for initializing the population age
structure. In the first approach, the initial population age structure
is derived by iterating the population to equilibrium:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Init</mtext></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mtext mathvariant="normal">Natmort</mtext><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><msub><mi>F</mi><mtext mathvariant="normal">mort,InitProp</mtext></msub><mo>⋅</mo><msub><mi>μ</mi><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mo>⋅</mo><msubsup><mtext mathvariant="normal">Sel</mtext><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">Fsh</mtext></msubsup><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>&lt;</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">cumsum</mtext><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Init</mtext></msubsup></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>a</mi><mi>′</mi><mo>=</mo><mn>1</mn></mrow><mi>a</mi></munderover><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mi>′</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Init</mtext></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
Z_{r,a,s}^{\text{Init}} &amp;= \text{Natmort}_{r,1,a,s} + F_{\text{mort,InitProp}} \cdot \mu_{f=1} \cdot \text{Sel}^{\text{Fsh}}_{r,1,a,s,f=1}, \quad \text{for } a &lt; a_+ \\
\text{cumsum}_{Z_{r,a,s}^{\text{Init}}} &amp;= \sum_{a'=1}^{a} Z_{r,a',s}^{\text{Init}}
\end{aligned}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">Z_{r,a,s}^{Init}</annotation></semantics></math>
is the initial instantaneous total mortality rate determined by the sum
of natural mortality and an inital fishing mortality rate. The initial
instantaneous fishing mortality rate is a user-specified value for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Fmort_{InitProp}</annotation></semantics></math>,
which represents the proportion of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\mu_{f=1}</annotation></semantics></math>
to apply to the initial age structure. In <code>SPoRC</code>, it is
generally recommended to structure associated data inptus for fishery
fleet 1 to represent the dominant fishery fleet.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup></msub></mrow><annotation encoding="application/x-tex">cumsum_{Z_{r,a,s}^{Init}}</annotation></semantics></math>
is the cumulative sum of the initial total mortality rate which is
initially applied to the equilibrium age structure following an
exponential motality model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>R</mi><mn>0</mn><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>R</mi><mn>0</mn><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mi>c</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
N_{r,a,s}^{Init} = \begin{cases}
R0 \psi_s \zeta_r, &amp; \text{if } a = 1 \\
R0 \exp\left(-cumsum_{Z_{r,a,s}^{Init}}\right)\psi_s\zeta_r, &amp; \text{if } a &gt; 1
\end{cases}
</annotation></semantics></math></p>
<p>If mean recruitment dynamics are assumed,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">R0</annotation></semantics></math>
in the above equation can simply be replaced with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>μ</mi><mi>r</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><annotation encoding="application/x-tex">\mu^{Rec}_{r}</annotation></semantics></math>.
Following determination of the equilibrium age structure, the initial
population is then iterated
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub><mo>⋅</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n_a \cdot 5</annotation></semantics></math>
times where movement is first applied, followed mortality and ageing
processes. In general, users might want to iterate the equilibrium age
structure if movement processes occur given that there is no simple
closed form solution to derive the plus-group of the population when
movement occurs.</p>
<p>Conversely, users can also specify an initial age structure
determined by a geometric series solution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>R</mi><mn>0</mn><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>μ</mi><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mn>2</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>R</mi><mn>0</mn><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mo>+</mo></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub><mo>⋅</mo><msub><mi>μ</mi><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mn>1</mn><mo>−</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>μ</mi><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><msub><mi>ψ</mi><mi>s</mi></msub><msub><mi>ζ</mi><mi>r</mi></msub><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>=</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
N_{r,a,s}^{Init} = \begin{cases}
R0 \exp\left(-(a-1)(Natmort_{r,1,a,s} + Fmort_{init}\mu_{f=1}Sel^{Fsh}_{r,1,a,s,f=1})\right)\psi_s\zeta_r, &amp; \text{if } 2 \leq a &lt; a_+ \\
\frac{R0 \exp\left(-(a_+ - 1)(Natmort_{r,1,a,s} + Fmort_{InitProp} \cdot \mu_{f=1}Sel^{Fsh}_{r,1,a,s,f=1})\right)}{1 - \exp\left(-(Natmort_{r,1,a,s} + Fmort_{init}\mu_{f=1}Sel^{Fsh}_{r,1,a,s,f=1})\right)}\psi_s\zeta_r, &amp; \text{if } a = a_+
\end{cases}
</annotation></semantics></math></p>
<p>This approach is generally more appropriate when movement does not
occur among regions, given that a closed form solution can easily be
derived for the plus-group. Initial age deviations can then be applied
to the equilibrium age structure:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo>=</mo><msubsup><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>a</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
N_{r,a,s}^{Init} = N_{r,a,s}^{Init} \exp(\epsilon_{r,a}^{Init})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Init}</annotation></semantics></math>
are initial age deviations <a href="#initpen">constrained by a normal
distribution</a>. Note that there are several options for initializing
the age structure. In particular, users can specify equilibrium age
structure, where deviations are assumed to be 0, stochastic age
structure with the plus group following the equilibrium solution, and
stochastic age structure with the plus group following the equilibrium
solution but with an additional deviation applied to the plus group.</p>
</div>
<div class="section level3">
<h3 id="selforms">Selectivity Processes (Fishery and Survey)<a class="anchor" aria-label="anchor" href="#selforms"></a>
</h3>
<p>Currently, several options are available for parameterizing fishery
and survey selectivity. Firstly, selectivity can be specified as either
being age-based or length-based. In the context of age-based
selectivity, the usual calculations occur where an age vector is
utilized to compute selectivity, given a specified functional form. In
the case of length-based selectivity, a length vector is utilized to
compute selectivity, after which the dot product of
selectivity-at-length and a size-age transition matrix is computeed to
derive selectivity-at-age:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><msup><mi>𝐥</mi><mi>𝐚</mi></msup></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>𝐀</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow><mi>l</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mrow><mi>𝐒</mi><mi>𝐞</mi><msup><mi>𝐥</mi><mi>𝐥</mi></msup></mrow></mrow><annotation encoding="application/x-tex">
\boldsymbol{Sel^a} = (\boldsymbol{A}^l_{r,y,s})^T \boldsymbol{Sel^l} 
</annotation></semantics></math></p>
<p>This derived selectivity-at-age is then used for all subsequent
calculations, given that the model is an age-based model.</p>
<p>Various functional forms can also be specified for selectivity
processes. In particular, two forms of logistic selectivity can be
specified. Throughout this section, we will use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
to denote a genearlized bin. The first form is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><msub><mi>l</mi><mi>b</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>−</mo><msup><mi>b</mi><mn>50</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">
Sel_{b} = \frac{1}{1 + \exp[-k(b - b^{50})]}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
regulates the slope/steepness of the logistic curve and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mn>50</mn></msup><annotation encoding="application/x-tex">b^{50}</annotation></semantics></math>
is the bin-at-50% selection. The second logistic form is expressed
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><msub><mi>l</mi><mi>b</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mn>19</mn><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mi>b</mi><mn>50</mn></msup><mo>−</mo><mi>b</mi></mrow><msup><mi>b</mi><mn>95</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
Sel_{b} = \frac{1}{1 + 19^{\left(\frac{b^{50} - b}{b^{95}}\right)}}
</annotation></semantics></math></p>
<p>Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msup><mi>b</mi><mn>50</mn></msup></mrow><annotation encoding="application/x-tex">ab^{50}</annotation></semantics></math>
is the bin-at-50% selection and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mn>95</mn></msup><annotation encoding="application/x-tex">b^{95}</annotation></semantics></math>
is the bin-at-95% selection. Selectivity can also be parameterized as a
gamma dome-shaped function:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>p</mi><mo>=</mo><mn>0.5</mn><mrow><mo stretchy="true" form="prefix">[</mo><msqrt><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>b</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">max</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mn>4</mn><msubsup><mi>γ</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mn>2</mn></msubsup></mrow></msqrt><mo>−</mo><msubsup><mi>b</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">max</mtext></msubsup><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mi>e</mi><msub><mi>l</mi><mi>b</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>b</mi><msubsup><mi>b</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">max</mtext></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>b</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">max</mtext></msubsup><mi>p</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></msup><msup><mi>e</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msubsup><mi>b</mi><mrow><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">max</mtext></msubsup><mo>−</mo><mi>b</mi></mrow><mi>p</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
p = 0.5 \left[ \sqrt{(b_{s,f}^{\text{max}})^2 + 4\gamma_{s,f}^2} - b_{s,f}^{\text{max}} \right] \\
Sel_{b} = \left( \frac{b}{b_{s,f}^{\text{max}}} \right)^{\left(\frac{b_{s,f}^{\text{max}}}{p}\right)} e^{\left( \frac{b_{s,f}^{\text{max}} - b}{p} \right)}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is a derived power parameter,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math>
is the shape parameter the describes the steepness of the descending
limb, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msup><annotation encoding="application/x-tex">b^{max}</annotation></semantics></math>
is an estimated parameter describing the bin-at-maximum selection. Other
dome-shaped functions are also available. In particular, this includes
the power function:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><msub><mi>l</mi><mi>b</mi></msub><mo>=</mo><mfrac><mn>1</mn><msup><mi>b</mi><mi>ϕ</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">
Sel_{b} = \frac{1}{b^{\phi}}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>
here is a power parameter determining the descending limb (larger values
are steeper).</p>
<p>The other function that is available includes the 6 parameter double
normal selectivity form. We define a parametric selectivity function
using a flexible compound form. Parameters are transformed from input
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><annotation encoding="application/x-tex">\hat{p}_1</annotation></semantics></math>
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>6</mn></msub><annotation encoding="application/x-tex">\hat{p}_6</annotation></semantics></math>
to define the shape.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>p</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mtext mathvariant="normal">min</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="normal">max</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">min</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>⋅</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Peak bin — beginning of the plateau</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>p</mi><mn>2</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>0.99</mn><mo>+</mo><msub><mtext mathvariant="normal">max</mtext><mi>x</mi></msub><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Width of plateau, smoothly approaches maximum bin</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>p</mi><mn>3</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>3</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>p</mi><mn>4</mn></msub><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>4</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Ascending and descending widths (on log scale)</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>p</mi><mn>5</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>5</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>p</mi><mn>6</mn></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>6</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Selectivity at first and last bins (logistic scale)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
p_1 &amp;= \text{min}(b) + [\text{max}(b) - \text{min}(b)] \cdot \frac{1}{1 + \text{exp}(-\hat{p}_1)}
&amp;&amp; \text{Peak bin — beginning of the plateau} \\
p_2 &amp;= p_1 + 1 + \frac{0.99 + \text{max}_x - p_1 - 1}{1 + \exp(-\hat{p}_2)} 
&amp;&amp; \text{Width of plateau, smoothly approaches maximum bin} \\
p_3 &amp;= \exp(\hat{p}_3), \quad 
p_4 = \exp(\hat{p}_4) 
&amp;&amp; \text{Ascending and descending widths (on log scale)} \\
p_5 &amp;= \frac{1}{1 + \exp(-\hat{p}_5)}, \quad 
p_6 = \frac{1}{1 + \exp(-\hat{p}_6)} 
&amp;&amp; \text{Selectivity at first and last bins (logistic scale)}
\end{align*}</annotation></semantics></math></p>
<p>Here, at low bins, the selectivity follows the ascending curve; at
intermediate bins, it plateaus around 1; at higher bins, it transitions
smoothly to the descending curve.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">asc</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msub><mi>p</mi><mn>3</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">Gaussian rise centered at </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">asc</mtext><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>p</mi><mn>5</mn></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mn>5</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mtext mathvariant="normal">asc</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">Rescales minimum to </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mn>5</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{asc}(b) &amp;= \exp\left( -\frac{(a - p_1)^2}{p_3} \right) 
&amp;&amp; \text{Gaussian rise centered at } p_1 \\
\text{asc}_{\text{scaled}}(b) &amp;= p_5 + (1 - p_5) \cdot \text{asc}(b) 
&amp;&amp; \text{Rescales minimum to } p_5
\end{align*}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">desc</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msub><mi>p</mi><mn>4</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">Gaussian fall centered at </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">stj</mtext></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>40</mn><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msub><mi>p</mi><mn>4</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">Reference value for rescaling </mtext><mspace width="0.333em"></mspace></mrow><mtext mathvariant="normal">desc</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">desc</mtext><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>6</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mfrac><mrow><mtext mathvariant="normal">desc</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>1</mn></mrow><mrow><mtext mathvariant="normal">stj</mtext><mo>−</mo><mn>1</mn></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">Descending scaled to reach </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mn>6</mn></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> at </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>=</mo><mn>40</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{desc}(b) &amp;= \exp\left( -\frac{(a - p_2)^2}{p_4} \right) 
&amp;&amp; \text{Gaussian fall centered at } p_2 \\
\text{stj} &amp;= \exp\left( -\frac{(40 - p_2)^2}{p_4} \right) 
&amp;&amp; \text{Reference value for rescaling } \text{desc} \\
\text{desc}_{\text{scaled}}(b) &amp;= 1 + (p_6 - 1) \cdot \frac{\text{desc}(b) - 1}{\text{stj} - 1} 
&amp;&amp; \text{Descending scaled to reach } p_6 \text{ at } a = 40
\end{align*}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">join</mtext><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>20</mn><mo>⋅</mo><mfrac><mrow><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><mrow><mn>1</mn><mo>+</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">|</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Logistic transition from asc to plateau</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">join</mtext><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>20</mn><mo>⋅</mo><mfrac><mrow><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><mrow><mn>1</mn><mo>+</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>a</mi><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">|</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">Logistic transition from plateau to desc</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{join}_1(b) &amp;= \frac{1}{1 + \exp\left( -20 \cdot \frac{a - p_1}{1 + |a - p_1|} \right)} 
&amp;&amp; \text{Logistic transition from asc to plateau} \\
\text{join}_2(b) &amp;= \frac{1}{1 + \exp\left( -20 \cdot \frac{a - p_2}{1 + |a - p_2|} \right)} 
&amp;&amp; \text{Logistic transition from plateau to desc}
\end{align*}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Sel</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mtext mathvariant="normal">asc</mtext><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mtext mathvariant="normal">join</mtext><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><mo>+</mo><msub><mtext mathvariant="normal">join</mtext><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mtext mathvariant="normal">join</mtext><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mtext mathvariant="normal">desc</mtext><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><msub><mtext mathvariant="normal">join</mtext><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{Sel}(b) &amp;= \text{asc}_{\text{scaled}}(b) \cdot (1 - \text{join}_1(b)) \\
&amp;\quad + \text{join}_1(b) \cdot \left[1 \cdot (1 - \text{join}_2(b)) + \text{desc}_{\text{scaled}}(b) \cdot \text{join}_2(b)\right]
\end{align*}</annotation></semantics></math></p>
<p>In addition to the various functional forms that can be specified to
describe selectivity processes, several parameterizations of
time-varying processes can be specified. In the simplest form,
time-varying selectivity can be specified as time blocks, where new
selectivity parameters are estimated for an arbitrary number of
user-specified periods. Several options are also available for <a href="#selpen">specifying continuous time-varying selectivity</a>, where
deviations are restricted to vary parametrically (i.e., deviations
applied to the parameters of a given selectivity form) or
semi-parametrically (i.e., deviations applied about the values of a
selectivity form). For example, if logistic selectivity is specified and
deviations are parametric, the following expression is invoked:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><msub><mi>k</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>−</mo><msubsup><mi>b</mi><mi>y</mi><mn>50</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>k</mi><mi>y</mi></msub><mo>=</mo><mi>k</mi><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>y</mi><mo>,</mo><mn>1</mn></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>b</mi><mi>y</mi><mn>50</mn></msubsup><mo>=</mo><msup><mi>b</mi><mn>50</mn></msup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>y</mi><mo>,</mo><mn>2</mn></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
Sel_{y,b} = \frac{1}{1 + \exp[-k_{y}(b - b_{y}^{50})]} \\
k_{y} = k \exp(\epsilon_{y,1}^{Sel}) \\
b_{y}^{50} = b^{50} \exp(\epsilon_{y,2}^{Sel}) 
\end{aligned}
</annotation></semantics></math></p>
<p>where the parameters of the logistic form are allowed to vary over
time. By contrast, in the case of semi-parametric deviations for
logistic selectivity, the following expression is used:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>−</mo><msup><mi>b</mi><mn>50</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi></mrow></msub></mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
Sel_{y,b} = \frac{1}{1 + \exp[-k(b - b^{50})]} \exp(\epsilon_{y,b}^{Sel}) \\
Sel_{y,b} = \frac{Sel_{y,b}}{mean(\boldsymbol{Sel})}
\end{aligned}
</annotation></semantics></math></p>
<p>where deviations are placed about the parametric form and selectivity
values are log mean standardized to aid with interpretability. Note that
if age-based selectivity is specified and continuous deviations are
estimated, these deviations are placed on the ages themselves. By
contrast, if length-based selectivity is specified and continuous
deviations are estimated, these deviations are placed on the lengths
themselves. For further details on options available, see the <a href="#selpen">selectivity process error section</a>.</p>
</div>
</div>
<div class="section level2">
<h2 id="observation-models-and-equations">Observation Models and Equations<a class="anchor" aria-label="anchor" href="#observation-models-and-equations"></a>
</h2>
<div class="section level3">
<h3 id="fishery-observation-model">Fishery Observation Model<a class="anchor" aria-label="anchor" href="#fishery-observation-model"></a>
</h3>
<p>The fishery observation model describes the expected catch-at-age,
catch-at-length, catch (in units of biomass), and fishery indices.
Expected catch-at-age
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>a</mi></msubsup><annotation encoding="application/x-tex">C^a_{r,y,a,s,f}</annotation></semantics></math>)
is calculated using Baranov’s catch equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>a</mi></msubsup><mo>=</mo><mfrac><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mrow><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mfrac><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
C^a_{r,y,a,s,f} = \frac{Fmort_{r,y,f}Sel^{Fsh}_{r,y,a,s,f}}{Z_{r,y,a,s}} N_{r,y,a,s} \left[1-\exp(-Z_{r,y,a,s})\right]
</annotation></semantics></math></p>
<p>Catch-at-length
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>l</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>l</mi></msubsup><annotation encoding="application/x-tex">C^l_{r,y,l,s,f}</annotation></semantics></math>)
can then be derived using catch-at-age
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>a</mi></msubsup><annotation encoding="application/x-tex">C^a_{r,y,a,s,f}</annotation></semantics></math>)
and a size-age transition matrix
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>𝐀</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow><mi>l</mi></msubsup><annotation encoding="application/x-tex">\boldsymbol{A}^l_{r,y,s}</annotation></semantics></math>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>l</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>l</mi></msubsup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>𝐀</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow><mi>l</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><msup><mi>𝐂</mi><mi>𝐚</mi></msup><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
C^l_{r,y,l,s,f} = (\boldsymbol{A}^l_{r,y,s})^T \boldsymbol{C^a}_{r,y,s,f}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>𝐀</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow><mi>l</mi></msubsup><annotation encoding="application/x-tex">\boldsymbol{A}^l_{r,y,s}</annotation></semantics></math>
is a data input derived external to the assessment model and is required
if users are fitting to length composition data, where the matrix
represents the probability of being in a length bin, given some age.</p>
<p>Expected catch
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">Catch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{Catch}_{r,y,f}</annotation></semantics></math>)
is then derived by simply taking the summation of the expected
catch-at-age across ages and sexes, multiplied by their respective
weights-at-age for the fishery:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Catch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mi>a</mi><msub><mi>a</mi><mo>+</mo></msub></munderover><munderover><mo>∑</mo><mi>s</mi><msub><mi>n</mi><mi>s</mi></msub></munderover><msubsup><mi>C</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mi>a</mi></msubsup><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">fish</mtext></msubsup></mrow><annotation encoding="application/x-tex">
\text{Catch}_{r,y,f} = \sum_a^{a_+} \sum_s^{n_s} C^a_{r,y,a,s,f} W_{r,y,a,s}^\text{fish}
</annotation></semantics></math></p>
<p>Fishery indices
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">FshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{FshIdx}_{r,y,f}</annotation></semantics></math>)
can be specified as either abundance-based (first equation below) or
biomass-based (second equation below):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">FshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><munderover><mo>∑</mo><mi>a</mi><msub><mi>a</mi><mo>+</mo></msub></munderover><munderover><mo>∑</mo><mi>s</mi><msub><mi>n</mi><mi>s</mi></msub></munderover><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mn>0.5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">FshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><munderover><mo>∑</mo><mi>a</mi><msub><mi>a</mi><mo>+</mo></msub></munderover><munderover><mo>∑</mo><mi>s</mi><msub><mi>n</mi><mi>s</mi></msub></munderover><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mn>0.5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">fish</mtext></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{FshIdx}_{r,y,f} = q^{Fsh}_{r,y,f} \sum_a^{a_+} \sum_s^{n_s} N_{r,y,a,s} \exp(-Z_{r,y,a,s}0.5) Sel_{r,y,a,s,f}^{Fsh} \\
\text{FshIdx}_{r,y,f} = q^{Fsh}_{r,y,f} \sum_a^{a_+} \sum_s^{n_s} N_{r,y,a,s} \exp(-Z_{r,y,a,s}0.5) Sel_{r,y,a,s,f}^{Fsh} W_{r,y,a,s}^\text{fish}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><annotation encoding="application/x-tex">q^{Fsh}_{r,y,f}</annotation></semantics></math>
is the catchability coefficient for a given fishery and the value 0.5
represents the fraction of year in which the fishery index should be
computed at. Currently, fishery catchability coefficients can only vary
over time as time blocks.</p>
</div>
<div class="section level3">
<h3 id="survey-observation-model">Survey Observation Model<a class="anchor" aria-label="anchor" href="#survey-observation-model"></a>
</h3>
<p>The survey observation model describes the expected survey
catch-at-age, survey catch-at-length, and survey indices. Expected
survey catch-at-age
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>a</mi></msubsup><annotation encoding="application/x-tex">I^a_{r,y,a,s,sf}</annotation></semantics></math>)
is calculated using the following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>a</mi></msubsup><mo>=</mo><msub><mi>N</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msub><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mn>0.5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">
I^a_{r,y,a,s,sf} = N_{r,y,a,s} \exp(-Z_{r,y,a,s}0.5) Sel_{r,y,a,s,sf}^{Srv} 
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">Sel_{r,y,a,s,sf}^{Srv}</annotation></semantics></math>
here is the survey selectivity pattern. Expected survey catch-at-length
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>l</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>l</mi></msubsup><annotation encoding="application/x-tex">I^l_{r,y,l,s,sf}</annotation></semantics></math>)
can then be derived as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>l</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>l</mi></msubsup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>𝐀</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi></mrow><mi>l</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><msup><mi>𝐈</mi><mi>𝐚</mi></msup><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
I^l_{r,y,l,s,sf} = (\boldsymbol{A}^l_{r,y,s})^T \boldsymbol{I^a}_{r,y,s,f}
</annotation></semantics></math></p>
<p>Again, survey indices
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">SrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{SrvIdx}_{r,y,sf}</annotation></semantics></math>)
can be computed either as abundance-based (first equation below), or
biomass-based (second equation below; where weight-at-age can be
survey-specific):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">SrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><munderover><mo>∑</mo><mi>a</mi><msub><mi>a</mi><mo>+</mo></msub></munderover><munderover><mo>∑</mo><mi>s</mi><msub><mi>n</mi><mi>s</mi></msub></munderover><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>a</mi></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">SrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><munderover><mo>∑</mo><mi>a</mi><msub><mi>a</mi><mo>+</mo></msub></munderover><munderover><mo>∑</mo><mi>s</mi><msub><mi>n</mi><mi>s</mi></msub></munderover><msubsup><mi>I</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mi>a</mi></msubsup><msubsup><mi>W</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">srv</mtext></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{SrvIdx}_{r,y,sf} = q^{Srv}_{r,y,sf} \sum_a^{a_+} \sum_s^{n_s} I^a_{r,y,a,s,sf} \\ 
\text{SrvIdx}_{r,y,sf} = q^{Srv}_{r,y,sf} \sum_a^{a_+} \sum_s^{n_s} I^a_{r,y,a,s,sf} W_{r,y,a,s}^\text{srv}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><annotation encoding="application/x-tex">q^{Srv}_{r,y,sf}</annotation></semantics></math>
is the survey catchability coefficient. Currently, several options are
available for parameterizing survey catchability. These include
time-blocks, where a unique value is estimated for each defined period.
Additionally, users can also input environmental covariates, which is
parameterized as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><mo>=</mo><msubsup><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><mo>⋅</mo><mi>e</mi><mi>x</mi><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>∑</mo><mi>k</mi></munder><msub><mi>β</mi><mi>k</mi></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>k</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
q^{Srv}_{r,y,sf} = \widehat{q}^{Srv}_{r,y,sf} \cdot exp(\sum_k \beta_k \cdot X_{k,r,y,sf})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
represents a multi-dimensional index vector that can accommodate various
effect types (fixed effects, interactions, and polynomials),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
is the covariate effect itself,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\beta_k</annotation></semantics></math>
are the regression coefficients for a given covariate, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow><mrow><mi>S</mi><mi>r</mi><mi>v</mi></mrow></msubsup><annotation encoding="application/x-tex">\hat{q}^{Srv}_{r,y,sf}</annotation></semantics></math>
is the mean catchability parameter.</p>
</div>
<div class="section level3">
<h3 id="tagging-observation-model">Tagging Observation Model<a class="anchor" aria-label="anchor" href="#tagging-observation-model"></a>
</h3>
<p>Tag cohorts
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">T^k_{r,y,a,s}</annotation></semantics></math>)
are dimensioned by regions, years, ages, and sexes, where index
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
denotes a unique tag cohort (release region and release year
combination). Tag cohorts are tracked for a user-specific maximum
duration (maximum tag liberty;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>L</mi></msub><annotation encoding="application/x-tex">n_L</annotation></semantics></math>),
after which calculations for the tag cohort are no longer computed. This
is done to help with computation time. Additionally, tag cohorts also
have the option to undergo a fraction of mortality in the year of
release, such that if a given cohort is released during the middle of
the year, mortality processes are discounted. If mortality discounting
is specified, movement does not occur in the year of release. In
general, the process dynamics for the tagged cohort mimics those
specified for the overall population. Immediately following release, tag
cohorts are decremented by an initial tag-induced mortality rate:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
T^k_{r,y,a,s} = T^k_{r,y,a,s} \exp(-\tau)
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
is the initial tag-induced mortality rate, which can either be estimated
freely or fixed at a user-specified value. In practice, this parameter
is often cofounded with other mortality processes and needs to be fixed.
If tagged cohorts are released at the beginning of a calendar year,
Markovian movement occurs (movement does not occur otherwise):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>𝐓</mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>𝐓</mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>𝐌</mi><mrow><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
\boldsymbol{T}^k_{y,a,s} = (\boldsymbol{T}^k_{y,a,s})^T \boldsymbol{M}_{y,a,s}
</annotation></semantics></math></p>
<p>Mortality and ageing of the tagged cohort then occurs:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for </mtext><mspace width="0.333em"></mspace></mrow><mi>a</mi><mo>=</mo><msub><mi>a</mi><mo>+</mo></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
T^k_{r,y+1,a+1,s} = T^k_{r,y,a,s}\exp(-Z^{Tag}_{r,y,a,s}), \quad \text{for } 1 \leq a &lt; a_+ \\
T^k_{r,y+1,a,s} =T^k_{r,y,a-1,s}\exp(-Z^{Tag}_{r,y,a-1,s}) + T^k_{r,y,a,s}\exp(-Z^{Tag}_{r,y,a,s}), \quad \text{for } a = a_+
\end{aligned}
</annotation></semantics></math></p>
<p>where tagged cohorts follow an exponential mortality model, with
accumulation of individuals in the plus-group. Total mortality for the
tagged cohort can be specified as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>κ</mi><mo>+</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>+</mo><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
Z^{Tag}_{r,y,a,s} = (\kappa + NatMort^{Tag}_{r,y,a,s} + FishMort^{Tag}_{r,y,a,s})
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>
is a parameter describing chronic tag loss, which can be estimated in
the model. However, this parameter should be fixed in practice, given
confounding with mortality processes. Natural mortality for tagged
individuals can be derived in several ways:</p>
<ol style="list-style-type: decimal">
<li>Natural mortality applied to tagged cohorts is averaged across ages
and sexes,</li>
<li>Natural mortality applied to tagged cohorts is averaged across
sexes, but is age-specific,</li>
<li>Natural mortality applied to tagged cohorts is averaged across ages,
but is sex-specific, and</li>
<li>Natural mortality is both age-and sex-specific:</li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><mrow><msub><mi>n</mi><mi>a</mi></msub><msub><mi>n</mi><mi>s</mi></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>s</mi></munder><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><msub><mi>n</mi><mi>s</mi></msub></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>a</mi></munder><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow><msub><mi>n</mi><mi>a</mi></msub></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
NatMort^{Tag}_{r,y,a,s} = \frac{\sum_a\sum_s NatMort_{r,y,a,s}}{n_an_s} \\
NatMort^{Tag}_{r,y,a,s} = \frac{\sum_s NatMort_{r,y,a,s}}{n_s} \\ 
NatMort^{Tag}_{r,y,a,s} = \frac{\sum_a NatMort_{r,y,a,s}}{n_a} \\ 
NatMort^{Tag}_{r,y,a,s} = NatMort_{r,y,a,s}
\end{aligned}
</annotation></semantics></math></p>
<p>The different calculations for natural mortality applied to tagged
cohorts might be used if the observed tagging data are not age-or
sex-specific such that calculations between observed and expected values
are consistent with the nature of tag recapture data (e.g., if tagging
data are not age-or sex-specific, one might use option 1). Similarly,
fishing mortality experienced by tagged cohorts can also be specified in
a multitude of ways:</p>
<ol style="list-style-type: decimal">
<li>Fishing mortality at age and sex from fleet 1 is applied to all ages
and sexes with uniform selectivity,</li>
<li>Fishing mortality at age and sex from fleet 1 is multiplied by
sex-averaged selectivity values,</li>
<li>Fishing mortality at age and sex from fleet 1 is multiplied by
sex-specific selectivity values,</li>
<li>Fishing mortality at age and sex is derived by taking the weighted
sum of annual fishing mortality across fleets with sex-averaged
selectivity values, and</li>
<li>Fishing mortality at age and sex is derived by taking the weighted
sum of annual fishing mortality across fleets with sex-specific
selectivity values:</li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mo>⋅</mo><mfrac><mrow><munder><mo>∑</mo><mi>s</mi></munder><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mrow><msub><mi>n</mi><mi>s</mi></msub></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow></msub><mo>⋅</mo><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><munderover><mo>∑</mo><mi>f</mi><msub><mi>n</mi><mi>f</mi></msub></munderover><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><munder><mo>∑</mo><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></munder><mrow><mo stretchy="true" form="prefix">[</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>⋅</mo><mfrac><mrow><munder><mo>∑</mo><mi>s</mi></munder><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup></mrow><msub><mi>n</mi><mi>s</mi></msub></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo>=</mo><munder><mo>∑</mo><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow></munder><mrow><mo stretchy="true" form="prefix">[</mo><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo>⋅</mo><mi>S</mi><mi>e</mi><msubsup><mi>l</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>s</mi><mi>h</mi></mrow></msubsup><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
FishMort^{Tag}_{r,y,a,s} = Fmort_{r,y,f=1} \\
FishMort^{Tag}_{r,y,a,s} = Fmort_{r,y,f=1} \cdot \frac{\sum_s Sel_{r,y,a,s,f=1}^{Fsh}}{n_s} \\
FishMort^{Tag}_{r,y,a,s} = Fmort_{r,y,f=1} \cdot Sel_{r,y,a,s,f=1}^{Fsh} \\
FishMort^{Tag}_{r,y,a,s} = \sum_f^{n_f} Fmort_{r,y,f} \\
FishMort^{Tag}_{r,y,a,s} = \sum_{f=1} \left[Fmort_{r,y,f} \cdot \frac{\sum_s Sel_{r,y,a,s,f}^{Fsh}}{n_s} \right] \\
FishMort^{Tag}_{r,y,a,s} = \sum_{f=1} \left[Fmort_{r,y,f} \cdot Sel_{r,y,a,s,f}^{Fsh} \right] 
\end{aligned}
</annotation></semantics></math></p>
<p>Again, users might specify different options depending on the nature
of observed recapture data. For instance, if sex-specific information
was not available, one might specify option 2 or 4 (sex-averaged
selectivity values).</p>
<p>To derive the expected number of recaptures, a modified version of
Baranov’s catch equation is used:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mfrac><mrow><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup></mrow><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup></mfrac><msubsup><mi>T</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msubsup><mi>Z</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{Recap}^k_{r,y,a,s} = \beta_{r,y} \frac{FishMort^{Tag}_{r,y,a,s}}{Z^{Tag}_{r,y,a,s}} T^k_{r,y,a,s} \left[1-\exp(-Z^{Tag}_{r,y,a,s})\right]
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><annotation encoding="application/x-tex">\beta_{r,y}</annotation></semantics></math>
represents a tag reporting rate parameter that can vary across space and
time. Currently, time-variation in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><annotation encoding="application/x-tex">\beta_{r,y}</annotation></semantics></math>
can only be specified as a time-block. Additionally,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><annotation encoding="application/x-tex">\beta_{r,y}</annotation></semantics></math>
is estimated as a logit variable:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mn>1</mn><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\beta_{r,y} = \frac{\exp(\beta^{'}_{r,y})}{1 + \exp(\beta^{'}_{r,y})}
</annotation></semantics></math></p>
<p>and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mi>′</mi></msubsup><annotation encoding="application/x-tex">\beta^{'}_{r,y}</annotation></semantics></math>
represents the tag reporting parameter in logit space.</p>
</div>
<div class="section level3">
<h3 id="observation-likelihoods">Observation Likelihoods<a class="anchor" aria-label="anchor" href="#observation-likelihoods"></a>
</h3>
<p>Currently, the generalized assessment model has the capability to fit
to a variety of data sources, which include:</p>
<ol style="list-style-type: decimal">
<li>fishery catches,</li>
<li>fishery indices,</li>
<li>fishery age compositions,</li>
<li>fishery length compositions,</li>
<li>survey indices,</li>
<li>survey age compositions,</li>
<li>survey length compositions, and</li>
<li>tagging data</li>
</ol>
<p>Each of these data sources are fit to using a statistical likelihood,
where each likelihood component summed together to compute the joint
negative log likelihood. Therefore, the joint negative log likelihood
represents the function to be minimized.</p>
<div class="section level4">
<h4 id="fishery-catches">Fishery Catches<a class="anchor" aria-label="anchor" href="#fishery-catches"></a>
</h4>
<p>Fishery catches can fit to using a lognormal likelihood, given by the
following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCatch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsCatch</mtext></msub><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msup><mi>σ</mi><mtext mathvariant="normal">ObsCatch</mtext></msup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCatch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">Catch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsCatch</mtext></msup></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
L(log(\text{ObsCatch}_{r,y,f})) = \lambda_{\text{ObsCatch}} \frac{1}{\sqrt{2\pi} \sigma^{\text{ObsCatch}}} \exp(-\frac{[log(\text{ObsCatch}_{r,y,f}) - log(\text{Catch}_{r,y,f})]^2}{2\sigma^{2^{\text{ObsCatch}}}})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">ObsCatch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{ObsCatch}_{r,y,f}</annotation></semantics></math>
represent the observed catches and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsCatch</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{ObsCatch}}}</annotation></semantics></math>
is the standard deviation of the catch. In general,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsCatch</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{ObsCatch}}}</annotation></semantics></math>
is not estimable and should be fixed at a small value (e.g., 1e-03) such
that catch is assumed to be known, which is the default in
<code>SPoRC</code>. Users should be able to easily modify this value in
the parameter list to something other than 1e-03 if desired.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mtext mathvariant="normal">ObsCatch</mtext></msub><annotation encoding="application/x-tex">\lambda_{\text{ObsCatch}}</annotation></semantics></math>
in this case represents a likelihood weight to apply to catch data
(generally not recommended to use and should be set to 1). In a case
where only spatially-aggregated catches are available for a period of
time, the model has the option to switch to an aggregated likelihood for
those defined periods:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCatch</mtext><mrow><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsCatch</mtext></msub><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msup><mi>σ</mi><mtext mathvariant="normal">ObsCatch</mtext></msup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCatch</mtext><mrow><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>∑</mo><mi>r</mi></munder><msub><mtext mathvariant="normal">Catch</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsCatch</mtext></msup></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
L(log(\text{ObsCatch}_{y,f})) = \lambda_{\text{ObsCatch}} \frac{1}{\sqrt{2\pi} \sigma^{\text{ObsCatch}}} \exp(-\frac{[log(\text{ObsCatch}_{y,f}) - log(\sum_r \text{Catch}_{r,y,f})]^2}{2\sigma^{2^{\text{ObsCatch}}}})
</annotation></semantics></math></p>
<p>where a lognormal likelihood is still assumed, but the expected
catches are summed across regions to derive spatially-aggregated
catch.</p>
</div>
<div class="section level4">
<h4 id="fishery-and-survey-indices">Fishery and Survey Indices<a class="anchor" aria-label="anchor" href="#fishery-and-survey-indices"></a>
</h4>
<p>Fishery indices can be fit to assuming a lognormal likelihood:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsFshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsFshIdx</mtext></msub><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msup><mi>σ</mi><mtext mathvariant="normal">ObsFshIdx</mtext></msup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsFshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">FshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsFshIdx</mtext></msup></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
L(log(\text{ObsFshIdx}_{r,y,f})) = \lambda_{\text{ObsFshIdx}} \frac{1}{\sqrt{2\pi} \sigma^{\text{ObsFshIdx}}} \exp(-\frac{[log(\text{ObsFshIdx}_{r,y,f}) - log(\text{FshIdx}_{r,y,f})]^2}{2\sigma^{2^{\text{ObsFshIdx}}}})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">ObsFshIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{ObsFshIdx}_{r,y,f}</annotation></semantics></math>
are the observed fishery indices and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsFshIdx</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{ObsFshIdx}}}</annotation></semantics></math>
describes the variance of the fishery index (can be estimated but should
theoretically be known).
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mtext mathvariant="normal">ObsFshIdx</mtext></msub><annotation encoding="application/x-tex">\lambda_{\text{ObsFshIdx}}</annotation></semantics></math>
represents a likelihood weight applied to fishery indices (should
ideally not be used and set at a value of 1 to allow the model to
objectively weight data sources using the specified variance).</p>
<p>Similarly, survey indices are fit to assuming a lognormal
likelihod:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsSrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsSrvIdx</mtext></msub><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msup><mi>σ</mi><mtext mathvariant="normal">ObsSrvIdx</mtext></msup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsSrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">SrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsSrvIdx</mtext></msup></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
L(log(\text{ObsSrvIdx}_{r,y,sf})) = \lambda_{\text{ObsSrvIdx}} \frac{1}{\sqrt{2\pi} \sigma^{\text{ObsSrvIdx}}} \exp(-\frac{[log(\text{ObsSrvIdx}_{r,y,sf}) - log(\text{SrvIdx}_{r,y,sf})]^2}{2\sigma^{2^{\text{ObsSrvIdx}}}})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">ObsSrvIdx</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>s</mi><mi>f</mi></mrow></msub><annotation encoding="application/x-tex">\text{ObsSrvIdx}_{r,y,sf}</annotation></semantics></math>
are the observed survey indices and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">ObsSrvIdx</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{ObsSrvIdx}}}</annotation></semantics></math>
describes the variance of the survey index (can be estimated but should
theoretically be known).
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mtext mathvariant="normal">ObsSrvIdx</mtext></msub><annotation encoding="application/x-tex">\lambda_{\text{ObsSrvIdx}}</annotation></semantics></math>
represents a likelihood weight applied to survey indices (should ideally
not be used and set at a value of 1 to allow the model to objectively
weight data sources using the specified variance).</p>
</div>
<div class="section level4">
<h4 id="fishery-and-survey-compositions">Fishery and Survey Compositions<a class="anchor" aria-label="anchor" href="#fishery-and-survey-compositions"></a>
</h4>
<p>At present, a total of 3 multivariate likelihoods are available for
use to fit to composition data. These include the multinomial, the
Dirichlet-multinomial, and logistic-normal likelihoods.</p>
<p>In the case of a multinomial likelihood, the following expression is
invoked:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCompositionData</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsCompositionData</mtext></msub><mo>⋅</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>⋅</mo><munderover><mo>∏</mo><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>b</mi></msub></munderover><msubsup><mi>E</mi><mi>b</mi><msub><mi>O</mi><mi>b</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">
L((\text{ObsCompositionData}_{r,y,f}) = \lambda_{\text{ObsCompositionData}} \cdot ISS \cdot \prod_{b = 1}^{n_b} E_b^{O_b} 
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">ISS</annotation></semantics></math>
is the input sample size that determines the initial weight to apply to
a given composition dataset, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mtext mathvariant="normal">ObsCompositionData</mtext></msub><annotation encoding="application/x-tex">\lambda_{\text{ObsCompositionData}}</annotation></semantics></math>
is the weight to apply to the input sample size after some form of
iterative re-weighting process (e.g., Francis).
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>b</mi></msub><annotation encoding="application/x-tex">E_b</annotation></semantics></math>
describes the expected values for a given bin
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mi>b</mi></msub><annotation encoding="application/x-tex">O_b</annotation></semantics></math>
describes the observed values.</p>
<p>If a Dirichlet-multinomial likelihood (linear parameterization) is
assumed, the following expression is used:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCompositionData</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsCompositionData</mtext></msub><mo>⋅</mo><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><munder><mo>∏</mo><mi>b</mi></munder><mi>I</mi><mi>S</mi><mi>S</mi><mo>⋅</mo><msub><mi>O</mi><mi>b</mi></msub><mo>+</mo><mn>1</mn></mrow></mfrac><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo>⋅</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>+</mo><mi>θ</mi><mo>⋅</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><munderover><mo>∏</mo><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>b</mi></msub></munderover><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>⋅</mo><msub><mi>O</mi><mi>b</mi></msub><mo>+</mo><mi>θ</mi><mo>⋅</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>⋅</mo><msub><mi>E</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>θ</mi><mo>⋅</mo><mi>I</mi><mi>S</mi><mi>S</mi><mo>⋅</mo><msub><mi>E</mi><mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
L(\text{ObsCompositionData}_{r,y,f}) = \lambda_{\text{ObsCompositionData}} \cdot \frac{\Gamma(ISS + 1)}{\prod_b ISS \cdot O_b + 1} \frac{\Gamma(\theta \cdot ISS)}{\Gamma(ISS + \theta \cdot ISS)} \prod_{b = 1}^{n_b} \frac{\Gamma(ISS \cdot O_b + \theta \cdot ISS \cdot E_b)}{\theta \cdot ISS \cdot E_b}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
here represents the overdispersion parameter such that the input sample
size can be adjusted to obtain an effective sample size
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">ESS</annotation></semantics></math>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>S</mi><mi>S</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>θ</mi></mrow></mfrac><mo>+</mo><mi>I</mi><mi>S</mi><mi>S</mi><mfrac><mi>θ</mi><mrow><mn>1</mn><mo>+</mo><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
ESS = \frac{1}{1 + \theta} + ISS \frac{\theta}{1 + \theta}
</annotation></semantics></math></p>
<p>Thus, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
was large such that
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>&gt;</mo><mo>&gt;</mo><mi>I</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\theta &gt;&gt; ISS</annotation></semantics></math>),
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>S</mi><mi>S</mi><mi>−</mi><mo>&gt;</mo><mi>I</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">ESS -&gt; ISS</annotation></semantics></math>,
while if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
was small such that
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>&lt;</mo><mo>&lt;</mo><mi>I</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\theta &lt;&lt; ISS</annotation></semantics></math>)
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
would approximate the ratio of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">ESS</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">ISS</annotation></semantics></math>.</p>
<p>Lastly, a logistic-normal likelihood can also be invoked, where
several covariance structures can be parameterized. In it’s simplest
form, an iid covariance can be specified:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝚺</mi><mo>=</mo><mi>𝐈</mi><mo>⋅</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\boldsymbol{\Sigma} = \boldsymbol{I} \cdot \theta^2
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\Sigma}</annotation></semantics></math>
is the covariance structure scaled by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>θ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\theta^2</annotation></semantics></math>
to allow for overdispersion and inter-annual variation in weighting.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\boldsymbol{I}</annotation></semantics></math>
is an identity matrix dimensioned by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub><mo>−</mo><mn>1</mn><mo>⋅</mo><msub><mi>n</mi><mi>b</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_b - 1 \cdot n_b - 1</annotation></semantics></math>.
A first-order autoregressive process can also be specified across
ages:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝚺</mi><mo>=</mo><msub><mi>𝐑</mi><mi>𝐚</mi></msub><mo>⋅</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\boldsymbol{\Sigma} = \boldsymbol{R_a} \cdot \theta^2
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐑</mi><mi>𝐚</mi></msub><annotation encoding="application/x-tex">\boldsymbol{R_a}</annotation></semantics></math>
is a matrix representing a first-order autoregressive process.
Two-dimensional autoregression can also be specified across ages and
sexes:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝚺</mi><mo>=</mo><msub><mi>𝐑</mi><mi>𝐚</mi></msub><mo>⊗</mo><msub><mi>𝐑</mi><mi>𝐬</mi></msub><mo>⋅</mo><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\boldsymbol{\Sigma} = \boldsymbol{R_a} \otimes \boldsymbol{R_s} \cdot \theta^2
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐑</mi><mi>𝐬</mi></msub><annotation encoding="application/x-tex">\boldsymbol{R_s}</annotation></semantics></math>
in this case is a constant correlation matrix by sex. Following the
specification of a covariance matrix, a logistic transformation is then
conducted on the observed and expected compositions, and a multivariate
normal likelihood is invoked on logistic random variables:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>O</mi><mi>b</mi><mi>′</mi></msubsup><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>O</mi><mrow><mi>−</mi><msub><mi>n</mi><mi>b</mi></msub></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>O</mi><msub><mi>n</mi><mi>b</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>E</mi><mi>b</mi><mi>′</mi></msubsup><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>E</mi><mrow><mi>−</mi><msub><mi>n</mi><mi>b</mi></msub></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>E</mi><msub><mi>n</mi><mi>b</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsCompositionData</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mtext mathvariant="normal">ObsCompositionData</mtext></msub><mo>⋅</mo><mn>2</mn><msup><mi>π</mi><mrow><mi>−</mi><mi>k</mi><mi>/</mi><mn>2</mn></mrow></msup><mtext mathvariant="normal">det</mtext><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝚺</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>−</mi><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>O</mi><mi>b</mi><mi>′</mi></msubsup><mo>−</mo><msubsup><mi>E</mi><mi>b</mi><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msup><mi>𝚺</mi><mrow><mi>−</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>O</mi><mi>b</mi><mi>′</mi></msubsup><mo>−</mo><msubsup><mi>E</mi><mi>b</mi><mi>′</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
O^{'}_b = log(O_{-n_b}) - log(O_{n_b}) \\
E^{'}_b = log(E_{-n_b}) - log(E_{n_b}) \\
L(\text{ObsCompositionData}_{r,y,f}) = \lambda_{\text{ObsCompositionData}} \cdot 2\pi^{-k/2} \text{det}(\boldsymbol{\Sigma})^{-1/2} \exp\left[-\frac{1}{2} (O^{'}_b - E^{'}_b)^T \boldsymbol{\Sigma}^{-1}(O^{'}_b - E^{'}_b)\right]
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>O</mi><mi>b</mi><mi>′</mi></msubsup><annotation encoding="application/x-tex">O^{'}_b</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>E</mi><mi>b</mi><mi>′</mi></msubsup><annotation encoding="application/x-tex">E^{'}_b</annotation></semantics></math>
are the observed and expected compositions after a logistic additive
transformation.</p>
<div class="section level5">
<h5 id="structuring-observed-and-expected-compositions">Structuring Observed and Expected Compositions<a class="anchor" aria-label="anchor" href="#structuring-observed-and-expected-compositions"></a>
</h5>
<p>Four options can be used for structuring age and length compositions.
These are:</p>
<ol style="list-style-type: decimal">
<li>Aggregated age or length compositions across regions and sexes,</li>
<li>‘Split’ age or length compositions for each region and sex (i.e., no
implicit information about region and sex-ratios),</li>
<li>‘Split’ age or length compositions for each region, coupled with
‘Joint’ compositions across sexes (i.e., implicit information about
sex-ratios, but no information about regional-ratios), and</li>
</ol>
<p>In the first option (termed ‘Aggregated’), both observed and expected
age or length compositions within a given year and fleet (survey or
fishery) are aggregated across both sexes and regions. For simplicity,
observed age and length compositions will be denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">O_{r,b,s}</annotation></semantics></math>
and expected age and length compositions will be denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">E_{r,b,s}</annotation></semantics></math>.
Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
represents either age or length bins. Note that observed compositions
will need to be aggregated prior to the modelling process (but need not
be normalized, as it is normalized within the modeling process).
Expected compositions are then first normalized by dividing the sum of a
given region and/or sex such that proportions sum to 1 within a given
region and a given sex. Following that, the average of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">E_{r,b,s}</annotation></semantics></math>
across regions and sexes is taken. If age compositions have ageing error
associated with them, the expected age compositions are then multiplied
by an ageing-error matrix to derive the compositions to fit to. Note
that a non-square (e.g., rectangular) ageing-error matrix can be
provided to reduce the number of modelled ages to align with the number
of observed composition ages. This approach is common for many rockfish
species in Alaska, where the model includes a greater number of ages
than are represented in the observed compositions. This allows for a
more accurate representation of population dynamics (by modelling more
ages), even though age estimates for older fish are often unreliable.
This process is described by the equations below:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>O</mi><mi>b</mi></msub><mo>=</mo><mfrac><msub><mi>O</mi><mi>b</mi></msub><mrow><munder><mo>∑</mo><mi>b</mi></munder><msub><mi>O</mi><mi>b</mi></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>E</mi><mi>b</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>n</mi><mi>s</mi></msub><mo>⋅</mo><msub><mi>n</mi><mi>r</mi></msub></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><msub><mi>n</mi><mi>s</mi></msub><mo>⋅</mo><msub><mi>n</mi><mi>r</mi></msub></mrow></munderover><mfrac><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><munder><mo>∑</mo><mi>b</mi></munder><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐄</mi><mo>=</mo><mi>𝐄</mi><mtext mathvariant="bold">𝐀𝐠𝐞𝐄𝐫𝐫𝐨𝐫</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐎</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>O</mi><mi>b</mi></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐄</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>E</mi><mi>b</mi></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
O_b = \frac{O_b}{\sum_b O_b} \\
E_b = \frac{1}{n_s \cdot n_r} \sum_{i = 1}^{n_s \cdot n_r} \frac{E_{r,b,s}}{\sum_b E_{r,b,s}} \\
\boldsymbol{E} = \boldsymbol{E} \textbf{AgeError} \\
\boldsymbol{O} = \left\{ O_b \;\middle|\; b = 1, \ldots, n_b \right\} \\
\boldsymbol{E} = \left\{ E_b \;\middle|\; b = 1, \ldots, n_b \right\}
\end{aligned}
</annotation></semantics></math></p>
<p>In the second option (termed ‘SplitRegionSplitSex’), both observed
and expected compositions for a given year and fleet are normalized to
sum to 1 within a given sex and region. For age compositions, an
ageing-error matrix can then applied to a given region and sex. This
process is mathematically described in the following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><munder><mo>∑</mo><mi>b</mi></munder><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><munder><mo>∑</mo><mi>b</mi></munder><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐄</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>𝐄</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mtext mathvariant="bold">𝐀𝐠𝐞𝐄𝐫𝐫𝐨𝐫</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐎</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐄</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
O_{r,b,s} = \frac{O_{r,b,s}}{\sum_b O_{r,b,s}} \\
E_{r,b,s} = \frac{E_{r,b,s}}{\sum_b E_{r,b,s}} \\
\boldsymbol{E}_{r,s} = \boldsymbol{E}_{r,s} \textbf{AgeError} \\
\boldsymbol{O}_{r,s} = \left\{ O_{r,b,s} \;\middle|\; b = 1, \ldots, n_b \right\} \\
\boldsymbol{E}_{r,s} = \left\{ E_{r,b,s} \;\middle|\; b = 1, \ldots, n_b \right\} 
\end{aligned}
</annotation></semantics></math></p>
<p>In the third option (termed ‘SplitRegionJointSex’), observed and
expected compositions for a given year and fleet are normalized to sum
to 1 within a given region, but jointly across sexes. For age
compositions, the ageing-error matrix can then extended to accommodate
such that it is dimensioned by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub><msub><mi>n</mi><mi>s</mi></msub><mo>⋅</mo><msub><mi>n</mi><mi>b</mi></msub><msub><mi>n</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">n_bn_s \cdot n_bn_s</annotation></semantics></math>,
and is given by the following equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><munder><mo>∑</mo><mrow><mi>b</mi><mo>,</mo><mi>s</mi></mrow></munder><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><munder><mo>∑</mo><mrow><mi>b</mi><mo>,</mo><mi>s</mi></mrow></munder><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐄</mi><mi>r</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐄</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐈</mtext><mo>⊗</mo><mtext mathvariant="bold">𝐀𝐠𝐞𝐄𝐫𝐫𝐨𝐫</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐎</mi><mi>r</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>O</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>s</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝐄</mi><mi>r</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>E</mi><mrow><mi>r</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mspace width="0.278em"></mspace><mo stretchy="true" form="infix">|</mo><mspace width="0.278em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>b</mi></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>s</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
O_{r,b,s} = \frac{O_{r,b,s}}{\sum_{b,s} O_{r,b,s}} \\
E_{r,b,s} = \frac{E_{r,b,s}}{\sum_{b,s} E_{r,b,s}} \\
\boldsymbol{E}_{r} = (\boldsymbol{E}_r)^T (\textbf{I} \otimes \textbf{AgeError}) \\
\boldsymbol{O}_r = \left\{ O_{r,b,s} \;\middle|\; b = 1,\ldots,n_b;\; s = 1,2 \right\} \\
\boldsymbol{E}_r = \left\{ E_{r,b,s} \;\middle|\; b = 1,\ldots,n_b;\; s = 1,2 \right\} 
\end{aligned}
</annotation></semantics></math></p>
</div>
</div>
<div class="section level4">
<h4 id="tagging">Tagging<a class="anchor" aria-label="anchor" href="#tagging"></a>
</h4>
<p>The generalized assessment model has the option to fit to tagging
data, which tracks a tag cohort across regions, ages, and sexes.
However, in many cases, age or sex information may not be available for
a given species. Thus, when tagging data does not include age or sex
information, the user must specify all tagged individuals to occupy the
first age class and first sex category as a starting point. Users should
then also specify tagging data to be fit via pooling across all ages and
sexes using the <code>move_age_tag_pool</code> and
<code>move_sex_tag_pool</code> data inputs under the scenario that no
information is available to distinguish age-and sex-specific tag
recaptures.</p>
<p>Given that tagging data is highly multi-dimensional, use of these
data can greatly increase the computational demand of the model.
Therefore, to partially reduce these demands, the model allows for
pooling of data across age and sex partitions. This process groups
observations and expected values into their respective age blocks. It is
recommended that if age-varying movement is estimated in age-blocks,
pooling of tag data should align with these age-blocks. Moreover, it is
important to note that when tag recoveries are fit to by pooling
observations and expected values, likelihood values for alternative
pooling parameterizations are not directly comparable.</p>
<p>Additionally, a central tenant of using tagging data is that tagged
individuals are representative of the overall population such that these
individuals need to be well-mixed. To address the well-mixed assumption,
the model allows for a specification of mixing period, which specifies
the time-at-liberty for which tags are fit to. For example, if all
individuals are well-mixed followed release, then the mixing period
would be specified at a value of 1. By contrast, if individuals are only
well-mixed after 2 years, then the mixing period would be specified at a
value of 2. Therefore, the model requires the entire history of a given
tag cohort to be input (starting from the initial release and recapture
year).</p>
<p>Currently, several tag likelihoods can be utilized to describe tag
recapture data. These options are: 1) Poisson likelihood, 2) Negative
Binomial likelihood, 3) Multinomial likelihood, assuming release
conditioned dynamics, and 4) Multinomial likelihood, assuming recapture
conditioned dynamics</p>
<p>The Poisson likelihood for tag recaptures is given by the following
expression:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></msup></mrow><mrow><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mi>!</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
L(\text{ObsRecap}_{r,y,a,s}) = \frac{\exp(-\text{Recap}^k_{r,y,a,s})(\text{Recap}^k_{r,y,a,s})^{\text{ObsRecap}_{r,y,a,s}}}{\text{ObsRecap}_{r,y,a,s}!}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\text{Recap}^k_{r,y,a,s}</annotation></semantics></math>
are observed tag recaptures. If pooling is specified, then observed
recoveries are fit to but summing the observed and expected tag
recoveries across the respective age and sex groups. In the model, the
likelihood is specified in log space, such that the factorial term in
the denominator is specified as a gamma function, allowing for
recoveries to be fit to as non-integer terms (as would be the case if an
age-length key were used to convert observed lengths to ages).</p>
<p>The negative binomial likelihood for tag recaptures is given by the
expression:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mi>η</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>η</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mrow><msub><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><mi>η</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msub><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>η</mi><mrow><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>+</mo><mi>η</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>η</mi></msup></mrow><annotation encoding="application/x-tex">
L(\text{ObsRecap}^k_{r,y,a,s}) = \frac{\Gamma(\text{ObsRecap}_{r,y,a,s} + \eta)}{\Gamma(\eta)\Gamma(\text{ObsRecap}_{r,y,a,s} + 1)} \left(\frac{\text{Recap}_{r,y,a,s}}{\text{Recap}_{r,y,a,s} + \eta}\right)^{\text{ObsRecap}_{r,y,a,s}} \left(\frac{\eta}{\text{Recap}_{r,y,a,s}^k + \eta}\right)^\eta
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
represents the overdispersion parameter for tagging data.</p>
<p>The multinomial release conditioned likelihood for tag recoveries
fits to both recaptured and non-recaptured states. Proportions of
observed
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mtext mathvariant="normal">PObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\text{PObsRecap}^k_{r,y,a,s}</annotation></semantics></math>)
and expected recaptured
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mtext mathvariant="normal">PRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\text{PRecap}^k_{r,y,a,s}</annotation></semantics></math>)
individuals are given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mtext mathvariant="normal">PRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><mfrac><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><msup><mtext mathvariant="normal">InitTag</mtext><mi>k</mi></msup></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mtext mathvariant="normal">PObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><mfrac><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><msup><mtext mathvariant="normal">InitTag</mtext><mi>K</mi></msup></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{PRecap}^k_{r,y,a,s} = \frac{\text{Recap}^k_{r,y,a,s}}{\text{InitTag}^k} \\ 
\text{PObsRecap}^k_{r,y,a,s} = \frac{\text{ObsRecap}^k_{r,y,a,s}}{\text{InitTag}^K} 
\end{aligned}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mtext mathvariant="normal">InitTag</mtext><mi>k</mi></msup><annotation encoding="application/x-tex">\text{InitTag}^k</annotation></semantics></math>
are the total tags released for a given tag cohort for a given release
region and year. Non-recaptured states can then be written as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msup><mtext mathvariant="normal">PNonRecap</mtext><mi>k</mi></msup><mo>=</mo><mn>1</mn><mo>−</mo><munder><mo>∑</mo><mi>r</mi></munder><munder><mo>∑</mo><mi>y</mi></munder><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><msubsup><mtext mathvariant="normal">PRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msup><mtext mathvariant="normal">PObsNonRecap</mtext><mi>k</mi></msup><mo>=</mo><mn>1</mn><mo>−</mo><munder><mo>∑</mo><mi>r</mi></munder><munder><mo>∑</mo><mi>y</mi></munder><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><msubsup><mtext mathvariant="normal">PObsNonRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{PNonRecap}^k = 1 - \sum_r \sum_y \sum_a \sum_s \text{PRecap}^k_{r,y,a,s} \\ 
\text{PObsNonRecap}^k = 1 - \sum_r \sum_y \sum_a \sum_s \text{PObsNonRecap}^k_{r,y,a,s}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mtext mathvariant="normal">PNonRecap</mtext><mi>k</mi></msup><annotation encoding="application/x-tex">\text{PNonRecap}^k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mtext mathvariant="normal">PObsNonRecap</mtext><mi>k</mi></msup><annotation encoding="application/x-tex">\text{PObsNonRecap}^k</annotation></semantics></math>
are the expected and observed non-recapture proportions, respectively.
Rewriting both recaptured and non-recaptured states for observed and
expected values gives:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>𝐄</mi><mtext mathvariant="normal">Tagging</mtext><mi>k</mi></msubsup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mtext mathvariant="bold">𝐏𝐑𝐞𝐜𝐚𝐩</mtext><mi>k</mi></msup><mo>,</mo><msup><mtext mathvariant="normal">PNonRecap</mtext><mi>k</mi></msup><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>𝐎</mi><mtext mathvariant="normal">Tagging</mtext><mi>k</mi></msubsup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mtext mathvariant="bold">𝐏𝐎𝐛𝐬𝐑𝐞𝐜𝐚𝐩</mtext><mi>k</mi></msup><mo>,</mo><msup><mtext mathvariant="normal">PObsNonRecap</mtext><mi>k</mi></msup><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\boldsymbol{E}^k_{\text{Tagging}} = \{\textbf{PRecap}^k, \text{PNonRecap}^k \} \\
\boldsymbol{O}^k_{\text{Tagging}} = \{\textbf{PObsRecap}^k, \text{PObsNonRecap}^k \}
\end{aligned}
</annotation></semantics></math></p>
<p>Following that, a standard multinomial likelihood with the
aforementioned vectors can be written as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mtext mathvariant="normal">InitTag</mtext><mi>k</mi></msup><munder><mo>∏</mo><mi>i</mi></munder><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mtext mathvariant="normal">Tagging</mtext></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mtext mathvariant="normal">Tagging</mtext></mrow><mi>k</mi></msubsup></msup></mrow><annotation encoding="application/x-tex">
L(\text{ObsRecap}^k_{r,y,a,s}) = \text{InitTag}^k \prod_i (E^k_{i,\text{Tagging}})^{O^k_{i,\text{Tagging}}}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
indexes a given element in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mtext mathvariant="normal">Tagging</mtext></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">E^k_{i,\text{Tagging}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mtext mathvariant="normal">Tagging</mtext></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">O^k_{i,\text{Tagging}}</annotation></semantics></math>.</p>
<p>The multinomial recapture conditioned likelihood for tag recoveries
assumes that tag shedding, tag induced mortality, and tag reporting
rates are spatially-invariant, given that these terms cancel out in the
denominator. Thus, these terms need not be specified or estimated when
assuming this likelihood. The following expression is used to transform
observed and expected recaptured individuals to proportions:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mtext mathvariant="normal">PRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><mfrac><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mrow><munder><mo>∑</mo><mi>r</mi></munder><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><msubsup><mtext mathvariant="normal">Recap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mtext mathvariant="normal">PObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo>=</mo><mfrac><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mrow><munder><mo>∑</mo><mi>r</mi></munder><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mtext mathvariant="normal">TotRecap</mtext><mi>y</mi><mi>k</mi></msubsup><mo>=</mo><munder><mo>∑</mo><mi>r</mi></munder><munder><mo>∑</mo><mi>a</mi></munder><munder><mo>∑</mo><mi>s</mi></munder><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{PRecap}^k_{r,y,a,s} = \frac{\text{Recap}^k_{r,y,a,s}}{\sum_r\sum_a\sum_s \text{Recap}^k_{r,y,a,s}} \\
\text{PObsRecap}^k_{r,y,a,s} = \frac{\text{ObsRecap}^k_{r,y,a,s}}{\sum_r\sum_a\sum_s \text{ObsRecap}^k_{r,y,a,s}} \\
\text{TotRecap}_y^k = \sum_r\sum_a\sum_s \text{ObsRecap}^k_{r,y,a,s} 
\end{aligned}
</annotation></semantics></math></p>
<p>where recapture probabilities are normalized by the sum of all
recaptures in a given year and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mtext mathvariant="normal">TotRecap</mtext><mi>y</mi><mi>k</mi></msubsup><annotation encoding="application/x-tex">\text{TotRecap}_y^k</annotation></semantics></math>
are the total number of observed recaptures within a given year. The
multinomial likelihood is then expressed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mtext mathvariant="normal">ObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mtext mathvariant="normal">TotRecap</mtext><mi>y</mi><mi>k</mi></msubsup><munder><mo>∏</mo><mi>i</mi></munder><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mtext mathvariant="normal">PRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">PObsRecap</mtext><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mi>k</mi></msubsup></msup></mrow><annotation encoding="application/x-tex">
L(\text{ObsRecap}^k_{r,y,a,s}) = \text{TotRecap}_y^k \prod_i (\text{PRecap}^k_{r,y,a,s})^{\text{PObsRecap}^k_{r,y,a,s}}
</annotation></semantics></math></p>
</div>
</div>
<div class="section level3">
<h3 id="priors">Priors<a class="anchor" aria-label="anchor" href="#priors"></a>
</h3>
<p>Several priors are available to help inform the estimation of
parameters. In particular, priors are available for natural mortality,
catchability, steepness, movement, and tag reporting rates.</p>
<div class="section level4">
<h4 id="natural-mortality">Natural Mortality<a class="anchor" aria-label="anchor" href="#natural-mortality"></a>
</h4>
<p>For natural mortality, a lognormal prior can be invoked:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msup><mi>σ</mi><mtext mathvariant="normal">NatMortPrior</mtext></msup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>M</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">Prior</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">NatMortPrior</mtext></msup></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
P(log(NatMort_{s = 1}) = \frac{1}{\sqrt{2\pi} \sigma^{\text{NatMortPrior}}} \exp(-\frac{[log(NatMort_{s = 1}) - log(Natmort_{s = 1}^{\text{Prior}})]^2}{2\sigma^{2^{\text{NatMortPrior}}}})
</annotation></semantics></math></p>
<p>where the lognormal prior is only invoked on the first sex (female if
sex-structured),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">NatMortPrior</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{NatMortPrior}}}</annotation></semantics></math>
represents the variance of the prior, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>r</mi><msubsup><mi>t</mi><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mtext mathvariant="normal">Prior</mtext></msubsup></mrow><annotation encoding="application/x-tex">Natmort_{s = 1}^{\text{Prior}}</annotation></semantics></math>
represents the prior value itself.</p>
</div>
<div class="section level4">
<h4 id="fishery-and-survey-catchability">Fishery and Survey Catchability<a class="anchor" aria-label="anchor" href="#fishery-and-survey-catchability"></a>
</h4>
<p>For fishery or survey catchability, a lognormal prior can similarly
be used:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><msubsup><mi>σ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">qPrior</mtext></msubsup></mrow></mfrac><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mfrac><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">Prior</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>σ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><msup><mn>2</mn><mtext mathvariant="normal">qPrior</mtext></msup></msubsup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
P(log(q_{r,y,f})) = \frac{1}{\sqrt{2\pi} \sigma_{r,y,f}^{\text{qPrior}}} \exp(-\frac{[log(q_{r,y,f}) - log(q_{r,y,f}^{\text{Prior}})]^2}{2\sigma^{2^{\text{qPrior}}}_{r,y,f}})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><msup><mn>2</mn><mtext mathvariant="normal">qPrior</mtext></msup></msup><annotation encoding="application/x-tex">\sigma^{2^{\text{qPrior}}}</annotation></semantics></math>
represents the variance of the prior, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>q</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mtext mathvariant="normal">qPrior</mtext></msubsup><annotation encoding="application/x-tex">q_{r,y,f}^{\text{qPrior}}</annotation></semantics></math>
represents the prior value itself.</p>
</div>
<div class="section level4">
<h4 id="steepness">Steepness<a class="anchor" aria-label="anchor" href="#steepness"></a>
</h4>
<p>If a Beverton-Holt stock recruitment relationship is assumed, priors
for steepness can be imposed. Currently, a scaled beta prior (bounded
between 0.2 and 1) can be invoked:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorMu</mtext></msubsup><mo>−</mo><mn>0.2</mn></mrow><mrow><mn>1</mn><mo>−</mo><mn>0.2</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorSD</mtext></msubsup><mrow><mn>1</mn><mo>−</mo><mn>0.2</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>b</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorMu</mtext></msubsup><mo>−</mo><mn>0.2</mn></mrow><mrow><mn>1</mn><mo>−</mo><mn>0.2</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorSD</mtext></msubsup><mrow><mn>1</mn><mo>−</mo><mn>0.2</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>h</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><msubsup><mi>h</mi><mi>r</mi><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>b</mi><mo>−</mo><mn>1</mn></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
a = \left(\frac{h^{\text{PriorMu}}_r - 0.2}{1 - 0.2}\right) \left(\frac{h^{\text{PriorSD}}_r }{1 - 0.2}\right)^2 \\ 
b = \left[1 - \left(\frac{h^{\text{PriorMu}}_r - 0.2}{1 - 0.2}\right)\right] \left[\left(\frac{h^{\text{PriorSD}}_r }{1 - 0.2}\right)^2\right] \\ 
P(h_r) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}h^{a-1}_r(1-h_r)^{b-1}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorMu</mtext></msubsup><annotation encoding="application/x-tex">h^{\text{PriorMu}}_r</annotation></semantics></math>
represents the prior mean steepness value in a given region (bounded
between 0.2 and 1) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>h</mi><mi>r</mi><mtext mathvariant="normal">PriorSD</mtext></msubsup><annotation encoding="application/x-tex">h^{\text{PriorSD}}_r</annotation></semantics></math>
is the standard deviation for those priors.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
are the shape parameters for a beta distribution.</p>
</div>
<div class="section level4">
<h4 id="movement">Movement<a class="anchor" aria-label="anchor" href="#movement"></a>
</h4>
<p>Priors on movement parameters can also be invoked, where these priors
are imposed on the rows of the movement matrix itself (as opposed to the
multinomial logit parameters). Here a Dirichlet prior can be
invoked:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mrow><mi>k</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>r</mi></msub></munderover><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>r</mi></msub></munderover><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>r</mi></msub></munderover><msubsup><mi>M</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mrow><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">
P(M_{k,y,a,s}) = \frac{\Gamma(\sum_{j=1}^{n_r} \alpha_{j,y,a,s})}{\prod_{j=1}^{n_r}\Gamma(\alpha_{j,y,a,s})} \prod_{j=1}^{n_r}M_{k,j,y,a,s}^{\alpha_{j,y,a,s}-1}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
indexes movement towards a given region and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{j,y,a,s}</annotation></semantics></math>
are the Dirichlet prior parameters. These priors have the flexibility to
be specified for movement of individuals towards region j for any year,
age, or sex partition. If a user were to specify a uniform prior, all
values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{j,y,a,s}</annotation></semantics></math>
would have the same values. Increasing the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{j,y,a,s}</annotation></semantics></math>
increases the concentration (i.e., the weight of the prior).</p>
</div>
<div class="section level4">
<h4 id="tag-reporting-rates">Tag Reporting Rates<a class="anchor" aria-label="anchor" href="#tag-reporting-rates"></a>
</h4>
<p>Two types of priors can be specified for facilitating the estimation
of tag reporting rates. In particular, the first type of prior includes
a symmetric beta parameterization, which is given by the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo>+</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>4</mn><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>β</mi><mtext mathvariant="normal">PriorScale</mtext></msup></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo>+</mo><mn>1</mn><mi>e</mi><mo>−</mo><mn>4</mn><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>β</mi><mtext mathvariant="normal">PriorScale</mtext></msup></msup></mrow><annotation encoding="application/x-tex">
P(\beta_{r,y}) = (\beta_{r,y} + 1e-4)^{\beta^{\text{PriorScale}} } (1 - \beta_{r,y} + 1e-4)^{\beta^{\text{PriorScale}}}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mtext mathvariant="normal">PriorScale</mtext></msup><annotation encoding="application/x-tex">\beta^{\text{PriorScale}}</annotation></semantics></math>
determines the scale of the tag reporting parameter and controls how
strongly to penalize estimates when they approach the bounds of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math>.
Larger values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mtext mathvariant="normal">PriorScale</mtext></msup><annotation encoding="application/x-tex">\beta^{\text{PriorScale}}</annotation></semantics></math>
result in larger penalties. By contrast, a standard beta distribution
can also be specified, with shape parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>.
This is given by the following expression:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mo>=</mo><mfrac><msup><mi>β</mi><mtext mathvariant="normal">PriorMu</mtext></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>β</mi><mtext mathvariant="normal">PriorSD</mtext></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>b</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mi>β</mi><mtext mathvariant="normal">PriorMu</mtext></msup></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>β</mi><mtext mathvariant="normal">PriorSD</mtext></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>Γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mspace width="0.167em"></mspace><msubsup><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>β</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>b</mi><mo>−</mo><mn>1</mn></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
a = \frac{\beta^{\text{PriorMu}}}{\left(\beta^{\text{PriorSD}}\right)^2} \\
b = \left[\frac{1 - \beta^{\text{PriorMu}}}{\left(\beta^{\text{PriorSD}}\right)^2}\right] \\
P(\beta_{r,y}) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)} \, \beta_{r,y}^{a-1} \left(1 - \beta_{r,y}\right)^{b-1}
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mtext mathvariant="normal">PriorMu</mtext></msup><annotation encoding="application/x-tex">\beta^{\text{PriorMu}}</annotation></semantics></math>
defines the mean of the distribution, while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mtext mathvariant="normal">PriorSD</mtext></msup><annotation encoding="application/x-tex">\beta^{\text{PriorSD}}</annotation></semantics></math>
defines the standard deviation of the beta distribution. Currently, only
a tag reporting rate priors are not region or year-specific (i.e., the
same value is applied across all regions and years).</p>
</div>
</div>
<div class="section level3">
<h3 id="penalties-process-error">Penalties (Process Error)<a class="anchor" aria-label="anchor" href="#penalties-process-error"></a>
</h3>
<div class="section level4">
<h4 id="initpen">Initial Age Deviations<a class="anchor" aria-label="anchor" href="#initpen"></a>
</h4>
<p>Estimation of initial age deviations is constrained by a normal
distribution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\epsilon_{r,y}^{Init} \sim N\left(0,\sigma^2_{Init}\right)
</annotation></semantics></math></p>
<p>with a mean of 0 and a variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{Init}</annotation></semantics></math>.
In <code>SPoRC</code>, these can either be estimated in a penalized
likelihood framework, where the variance parameter is fixed at a known
value and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Init}</annotation></semantics></math>
are estimated as fixed-effects. Conversely, a random effects framework
can also be used where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Init}</annotation></semantics></math>
are treated as random effects and are integrated out using Laplace
approximation.</p>
</div>
<div class="section level4">
<h4 id="recruitmentpen">Recruitment<a class="anchor" aria-label="anchor" href="#recruitmentpen"></a>
</h4>
<p>Similarly, estimation of recruitment deviations is constrained by a
normal distribution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\epsilon_{r,y}^{Rec} \sim N\left(0,\sigma^2_{Rec}\right)
</annotation></semantics></math></p>
<p>with a mean of 0 and a variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{Rec}</annotation></semantics></math>.
Again, recruitment deviations can either be estimated in a penalized
likelihood framework, where the variance parameter is fixed at a known
value and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Rec}</annotation></semantics></math>
are estimated as fixed-effects. Conversely,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi></mrow><mrow><mi>R</mi><mi>e</mi><mi>c</mi></mrow></msubsup><annotation encoding="application/x-tex">\epsilon_{r,y}^{Rec}</annotation></semantics></math>
can also be treated as random effects and integrated out using Laplace
approximation.</p>
</div>
<div class="section level4">
<h4 id="fishmortpen">Fishing Mortality<a class="anchor" aria-label="anchor" href="#fishmortpen"></a>
</h4>
<p>Fishing mortality deviations are also constrained by a normal
distribution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\epsilon_{r,y,f}^{Fmort} \sim N\left(0,\sigma^2_{Fmort}\right)
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{Fmort}</annotation></semantics></math>
is fixed at an arbitrary value to ensure that observed catches are fit
to adequately. Given that values of observed catch are generally known
with negligible error, the value specified for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{Fmort}</annotation></semantics></math>
should be inconsequential. It is generally necessary to constrain
fishing mortality deviations to ensure that all parameters are
identifiable. Currently,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>F</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{Fmort}</annotation></semantics></math>
can be specified as either random effects or penalized likelihood. Under
a penalized likelihood framework, this value is fixed at 1, although
this can be easily modified by the user.</p>
</div>
<div class="section level4">
<h4 id="selpen">Selectivity (Fishery and Survey)<a class="anchor" aria-label="anchor" href="#selpen"></a>
</h4>
<p>Several options can be specified to parameterize continuous
time-varying selectivity. For all forms, users can specify deviations to
occur in a penalized likelihood framework, or in a random effects
framework. The simplest form represents iid deviations about selectivity
parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
for a given functional form:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>,</mo><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\epsilon_{r,y,i,s,f}^{Sel} \sim N\left(0,\sigma^2_{i,Sel}\right)
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>,</mo><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{i,Sel}</annotation></semantics></math>
is the variance of selectivity parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mn>50</mn></msup><annotation encoding="application/x-tex">a^{50}</annotation></semantics></math>).
Using this form, selectivity is assumed to vary across time but in a
parametric manner.</p>
<p>Parametric selectivity deviations can also be specified assuming a
random walk process:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>25</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϵ</mi><mrow><mi>r</mi><mo>,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>,</mo><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr></mtable></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex"> 
\begin{aligned}
\epsilon_{r,y,i,s,f}^{Sel} \begin{cases}
\sim N\left(0,25\right), &amp; \text{if } y = 1 \\
\sim N\left(\epsilon_{r,y-1,i,s,f}^{Sel},\sigma^2_{i,Sel}\right) &amp; \text{if } y &gt; 1
\end{cases}
\end{aligned}
</annotation></semantics></math></p>
<p>where the first parameter deviation is initialized with a broad
distribution (essentially a fixed effect parameter), and subsequent
deviations are dependent on the previous time point, constrained by an
estimable variance for a given selectivity parameter
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>,</mo><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{i,Sel}</annotation></semantics></math>).
For both iid and random walk deviations, a smoothness penalty is applied
onto selectivity values to induce temporal stability:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mtext mathvariant="normal">year smoothness</mtext></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mi>S</mi></munderover><munderover><mo>∑</mo><mrow><mi>y</mi><mo>=</mo><mn>2</mn></mrow><mi>Y</mi></munderover><munderover><mo>∑</mo><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
P_{\text{year smoothness}} = \sum_{s=1}^S\sum_{y=2}^{Y} \sum_{b=1}^{B} (log(Sel_{y,b,s}) - log(Sel_{y-1,b,s}))^2
</annotation></semantics></math></p>
<p>Semi-parametric deviations can also be specified, where deviations
can occur across years, bins (age or length), and cohorts. For all
semi-parametric deviations, a curvature penalty is applied on
selectivity values across bins and across years for regularity:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>P</mi><mtext mathvariant="normal">bin curvature</mtext></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mi>S</mi></munderover><munderover><mo>∑</mo><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><mi>Y</mi></munderover><munderover><mo>∑</mo><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow><mrow><mi>b</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>2</mn><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>P</mi><mtext mathvariant="normal">year curvature</mtext></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><mi>S</mi></munderover><munderover><mo>∑</mo><mrow><mi>y</mi><mo>=</mo><mn>2</mn></mrow><mrow><mi>Y</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>2</mn><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mi>e</mi><msub><mi>l</mi><mrow><mi>y</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>b</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
P_{\text{bin curvature}} = \sum_{s=1}^S\sum_{y=1}^{Y} \sum_{b=2}^{b-1} (log(Sel_{y,b+1,s}) - 2log(Sel_{y,b,s}) - log(Sel_{y,b-1,s}))^2 \\
P_{\text{year curvature}} = \sum_{s=1}^S\sum_{y=2}^{Y-1} \sum_{b=1}^{B} (log(Sel_{y+1,b,s}) - 2log(Sel_{y,b,s}) - log(Sel_{y-1,b,s}))^2 \\
\end{aligned}
</annotation></semantics></math></p>
<p>Two options can be specified to allow for deviations across the
dimensions of ages, years, and cohorts (and note that this is only
possible when age-based selectivity is specified), which include a
marginal stationary and a conditional non-stationary variance option.
The primary difference between the two is that the marginal variance
version does not have a closed form solution for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛀</mi><annotation encoding="application/x-tex">\boldsymbol{\Omega}</annotation></semantics></math>
(see equations below) and needs to be iteratively solved, while the
conditional variance version has a closed form solution. The following
equations describe the conditional variance version:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>𝛜</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo>∼</mo><mtext mathvariant="normal">MVN</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mtext mathvariant="bold">𝐐</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\boldsymbol{\epsilon}_{r,s,f}^{Sel} \sim \text{MVN}(0,\textbf{Q}) 
</annotation></semantics></math></p>
<p>where process error arises from a multivariate normal distribution
with precision matrix
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>;
inverse of the covariance). Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
is constructed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="bold">𝐐</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐈</mtext><mo>−</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐁</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>𝛀</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐈</mtext><mo>−</mo><mtext mathvariant="bold">𝐁</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">diag</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛀</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mrow><mi>−</mi><mn>2</mn></mrow></msubsup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\textbf{Q} = (\textbf{I} - (\textbf{B})^T) \boldsymbol{\Omega} (\textbf{I} - \textbf{B}) \\
\text{diag}(\boldsymbol{\Omega}) = \sigma_{Sel}^{-2}
\end{aligned}
</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐈</mtext><annotation encoding="application/x-tex">\textbf{I}</annotation></semantics></math>
is an identity matrix and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛀</mi><annotation encoding="application/x-tex">\boldsymbol{\Omega}</annotation></semantics></math>
is a diagonal matrix that determines the variance of the multivariate
normal process.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐁</mtext><annotation encoding="application/x-tex">\textbf{B}</annotation></semantics></math>
is a square matrix representing the partial effect of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>𝛜</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><annotation encoding="application/x-tex">\boldsymbol{\epsilon}_{r,s,f}^{Sel}</annotation></semantics></math>
on preceeding ages and/or years, governing by partial correlation
coefficients for ages, years, and cohorts. To demonstrate the
formulation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐁</mtext><annotation encoding="application/x-tex">\textbf{B}</annotation></semantics></math>,
a simplified example is provided with rows representing ages
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>ϵ</mi><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">a \epsilon \{1,2\}</annotation></semantics></math>
and columns representing years
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>ϵ</mi><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">t \epsilon \{1,2\}</annotation></semantics></math>.
In this example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐁</mtext><annotation encoding="application/x-tex">\textbf{B}</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>x</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">4 x 4</annotation></semantics></math>
matrix, where both the rows and columns represent combinations of age
and year. For instance,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>B</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><annotation encoding="application/x-tex">B_{1,2}</annotation></semantics></math>
captures the correlation within the same year between age 1 in year 1,
and age 2 in year 1, whereas
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>B</mi><mrow><mn>4</mn><mo>,</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">B_{4,1}</annotation></semantics></math>
constructs the correlation within the same cohort between age 1 in year
1, and age 2 in year 2:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐁</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>y</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>a</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>c</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>a</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>y</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mathbf{B} = \begin{bmatrix} 
1 &amp; 0 &amp; 0 &amp; 0 \\
\rho_y &amp; 0 &amp; 0 &amp; 0 \\
\rho_a &amp; 0 &amp; 0 &amp; 0 \\
\rho_c &amp; \rho_a &amp; \rho_y &amp; 0
\end{bmatrix}
\end{aligned}
</annotation></semantics></math></p>
<p>Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\rho_y</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\rho_a</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\rho_c</annotation></semantics></math>
are parameters describing the partial autocorrelation among years within
a given age, among ages within a given year, and years within a cohort,
respectively.</p>
<p>Lastly, semi-parametric deviations can also be specified to vary
across years and bins (i.e., in a two-dimensional manner; this option
can be utilized for both age-and length-based selectivity). Similar to
the process described above, selectivity deviations are constrained by a
precision matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>,
following a multivarite normal process:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>𝛜</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>f</mi></mrow><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow></msubsup><mo>∼</mo><mtext mathvariant="normal">MVN</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mtext mathvariant="bold">𝐐</mtext><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msup><mtext mathvariant="bold">𝐐</mtext><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo>=</mo><mfrac><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>e</mi><mi>l</mi></mrow><mn>2</mn></msubsup><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>ρ</mi><mi>y</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>ρ</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></mfrac><msub><mtext mathvariant="bold">𝐑</mtext><mi>y</mi></msub><mo>⊗</mo><msub><mtext mathvariant="bold">𝐑</mtext><mi>b</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\boldsymbol{\epsilon}_{r,s,f}^{Sel} \sim \text{MVN}(0,\textbf{Q}^{-1}) \\
\textbf{Q}^{-1} = \frac{\sigma^2_{Sel}}{(1-\rho_y)^2(1-\rho_b)^2}\textbf{R}_y \otimes \textbf{R}_b \\ 
\end{aligned}
</annotation></semantics></math></p>
<p>where is determined by the Kronecker product of a first-order
autoregressive process across bins
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐑</mtext><mi>b</mi></msub><annotation encoding="application/x-tex">\textbf{R}_b</annotation></semantics></math>
and across years
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐑</mtext><mi>y</mi></msub><annotation encoding="application/x-tex">\textbf{R}_y</annotation></semantics></math>.</p>
</div>
<div class="section level4">
<h4 id="movepen">Movement Deviations<a class="anchor" aria-label="anchor" href="#movepen"></a>
</h4>
<p>Continuous movement deviations can also be estimated under a random
effects or penalized likelihood framework. Currently, only iid
deviations are allowed, where deviations are placed upon fixed-effects
movement parameters in logit space:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mrow><mi>k</mi><mo>,</mo><mi>−</mi><mn>1</mn><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>ω</mi><mrow><mi>k</mi><mo>,</mo><mi>−</mi><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo>+</mo><msubsup><mi>ϵ</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Move</mtext></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>ϵ</mi><mrow><mi>k</mi><mo>,</mo><mi>−</mi><mn>1</mn><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Move</mtext></msubsup><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mrow><mi>k</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\omega_{k,-1,y,a,s} = \omega_{k,-1,s} + \epsilon^{\text{Move}}_{k,j,y,a,s} \\
\epsilon^{\text{Move}}_{k,-1,y,a,s} \sim N(0,\sigma^2_{k,a,s})
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϵ</mi><mrow><mi>k</mi><mo>,</mo><mi>−</mi><mn>1</mn><mo>,</mo><mi>y</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mtext mathvariant="normal">Move</mtext></msubsup><annotation encoding="application/x-tex">\epsilon^{\text{Move}}_{k,-1,y,a,s}</annotation></semantics></math>
are movement deviatons in logit space. Because of the sum to 1
constraint, movement deviations are only estimated for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>r</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_r - 1</annotation></semantics></math>.
Deviations then arise from a normal distribution with process variation
constrained by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mrow><mi>k</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>s</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma^2_{k,a,s}</annotation></semantics></math>.
Thus, process variance can be distinct by the origin region and age
(although other parameterizations that share all parameters across
origin region, ages, and sexes are also allowed). Similarly, process
deviations can be invoked only across years, ages, years and ages,
years, ages, and sexes, etc. This flexibility is maintained given the
computational demand for estimating random effects for movement.</p>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Matthew Cheng.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer>
</div>





  </body>
</html>
